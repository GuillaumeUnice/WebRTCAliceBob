{"version":3,"sources":["webpack:///WebRtcCDN.min.js","webpack:///webpack/bootstrap fcf2de7b15044910fc46","webpack:///./src/WebRTCLib.ts","webpack:///./src/index.ts","webpack:///./~/ws-jms-lib-echyzen/dist/WsJMSLib.js","webpack:///./~/ws-jms-lib-echyzen/dist/index.js"],"names":["WebRtcCDN","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ws_jms_lib_echyzen_1","WebRTCLib","url","channelID","userID","_this","this","listTempRemoteIceCandidate","myRTCPeerConnection","getBrowserRTCConnectionObj","wsJmsLib","connect","subscribe","dispatchMessage","prototype","message","JSON","parse","console","log","type","user_id","setRemoteDescription","RTCSessionDescription","tempRemoteDesc","createAnswer","myDesc","getDescription","err","error","push","forEach","remoteIceCandidate","addIceCandidate","RTCIceCandidate","responseWebRTC","remoteDesc","servers","constraints","optional","window","mozRTCPeerConnection","webkitRTCPeerConnection","RTCPeerConnection","buildMessage","chatroom_id","sendIceCandidates","myRTCIceCandidateEvent","lightRTCIceCandidateEvent","candidate","sdpMid","sdpMLineIndex","send","stringify","setLocalDescription","createStream","userMediaStream","getLocalStream","getRemoteStream","navigator","getUserMedia","myStream","addStream","onicecandidate","onaddstream","evt","stream","createOffer","attachStream","mediaStream","HTMLElement","attachMediaStream","WebRTCLib_1","connection","session","consumers","createDestination","name","reTopic","RegExp","baseTopicUrl","reQueue","baseQueueUrl","match","createTopic","createQueue","Error","textMessage","createTextMessage","callback","connectionFactory","JmsConnectionFactory","that","connectionFuture","createConnection","getValue","createSession","Session","AUTO_ACKNOWLEDGE","start","channelName","messageListener","context","topic","consumer","createConsumer","setMessageListener","getText","dest","producer","createProducer","future_1","exception","e","close","unsubscribe","WsJMSLib_1"],"mappings":"AAAA,GAAIA,WACK,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,UAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,UAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDOM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GAE/B,YEtDD,IAAAW,GAAAX,EAAuB,GAwBvBY,EAAA,WAUC,QAAAA,GAAoBC,EAAqBC,EAA2BC,GAVrE,GAAAC,GAAAC,IAUqBA,MAAAJ,MAAqBI,KAAAH,YAA2BG,KAAAF,SAF3DE,KAAAC,8BAIND,KAAKE,oBAAsBF,KAAKG,6BAChCH,KAAKI,SAAW,GAAIV,GAAAU,SAEpBJ,KAAKI,SAASC,QAAQT,EAAK,WACzBG,EAAKK,SAASE,UAAUT,EAAWE,EAAKQ,gBAAiBR,KAwI/D,MApIUJ,GAAAa,UAAAD,gBAAR,SAAwBE,GAAxB,GAAAV,GAAAC,IAGE,QAFAS,EAAUC,KAAKC,MAAMF,GACrBG,QAAQC,IAAI,kBAAmBJ,GACvBA,EAAQK,MACd,IAAK,kBACAd,KAAKF,SAAWW,EAAQM,UACzBH,QAAQC,IAAI,kBAAmBJ,GAC/BT,KAAKE,oBAAoBc,qBACvB,GAAIC,uBAAsBjB,KAAKkB,gBAC/B,WACEnB,EAAKG,oBAAoBiB,aACvB,SAACC,GACCrB,EAAKsB,eAAeD,IAEtB,SAACE,GAAe,MAAAV,SAAQW,MAAMD,MACjC,SAACA,GAAe,MAAAV,SAAQW,MAAMD,KAEjCtB,KAAKkB,eAAiBT,EAExB,MAEF,KAAK,wBACAT,KAAKF,SAAWW,EAAQM,UACzBH,QAAQC,IAAI,wBAAyBJ,GAClCA,EAAQA,QACTT,KAAKC,2BAA2BuB,KAAKf,EAAQA,SAE7CT,KAAKC,2BAA2BwB,QAAQ,SAACC,GACvC3B,EAAKG,oBAAoByB,gBAAgB,GAAIC,iBAAgBF,MAKnE,MAEF,KAAK,mBACA1B,KAAKF,SAAWW,EAAQM,UACzBH,QAAQC,IAAI,mBAAoBJ,GAChCT,KAAK6B,eAAepB,EAAQA,YAW5Bd,EAAAa,UAAAqB,eAAR,SAAuBC,GACrB9B,KAAKE,oBAAoBc,qBAAqB,GAAIC,uBAAsBa,KAGlEnC,EAAAa,UAAAL,2BAAR,WACE,GAAI4B,GAA4B,KAC5BC,GACFC,YAEF,OAAIC,QAAOC,qBACF,GAAIA,sBAAqBJ,EAASC,GAChCE,OAAOE,wBACP,GAAIA,yBAAwBL,EAASC,GAEvC,GAAIK,mBAAkBN,EAASC,IAIlCrC,EAAAa,UAAA8B,aAAR,SAAqB7B,EAAcK,GACjC,OACEyB,YAAavC,KAAKH,UAClBkB,QAASf,KAAKF,OACdgB,KAAMA,EACNL,QAASA,IAILd,EAAAa,UAAAgC,kBAAR,SAA0BC,GACxB,GAAIC,GAAiC,IACjCD,GAAuBE,YACzBD,GACEE,OAAQH,EAAuBE,UAAUC,OACzCC,cAAeJ,EAAuBE,UAAUE,cAChDF,UAAWF,EAAuBE,UAAUA,WAGhD,IAAIlC,GAAUT,KAAKsC,aAAaI,EAA2B,wBAC3D1C,MAAKI,SAAS0C,KAAKpC,KAAKqC,UAAUtC,GAAUT,KAAKH,UAAW,eAGtDF,EAAAa,UAAAa,eAAR,SAAuBD,GAAvB,GAAArB,GAAAC,IACEA,MAAKE,oBAAoB8C,oBAAoB5B,EAC3C,WACA,GAAIX,GAAUV,EAAKuC,aAAalB,EAAQ,mBACxCrB,GAAKK,SAAS0C,KAAKpC,KAAKqC,UAAUtC,GAAUV,EAAKF,UAAW,iBAK1DF,EAAAa,UAAAyC,aAAP,SAAoBC,EACjBC,EACAC,GAFH,GAAArD,GAAAC,IAIGqD,WAAUC,aAAaJ,EAAiB,SAACK,GAEzCxD,EAAKG,oBAAoBsD,UAAUD,GAC/BJ,EAAeI,GAEfxD,EAAKG,oBAAoBuD,eAAiB,SAAChB,GACzC1C,EAAKyC,kBAAkBC,IAG7B1C,EAAKG,oBAAoBwD,YAAc,SAACC,GAClCP,EAAgBO,EAAIC,UAGxB,SAACtC,GAAe,MAAAV,SAAQW,MAAMD,MAI3B3B,EAAAa,UAAAqD,YAAP,cAAA9D,GAAAC,IACEA,MAAKE,oBAAoB2D,YAAa,SAACzC,GACrCrB,EAAKG,oBAAoB8C,oBAAoB5B,EAC7C,IAAIX,GAAUV,EAAKuC,aAAalB,EAAQ,kBACxCrB,GAAKK,SAAS0C,KAAKpC,KAAKqC,UAAUtC,GAAUV,EAAKF,UAAW,eAC5D,SAACyB,GAAiBV,QAAQW,MAAMD,MAI7B3B,EAAAmE,aAAP,SAAoBC,EAA0BC,GAC5CA,EAAcC,kBAAkBD,EAAaD,IAGjDpE,IAxJaT,GAAAS,UAASA,GFkLhB,SAASR,EAAQD,EAASH,GAI/B,YG3MD,IAAAmF,GAAAnF,EAAwB,EAAhBG,GAAAS,UAAAuE,EAAAvE,WHkNF,SAASR,EAAQD,GIpNvB,YACA,IAAAkB,GAAA,WAEA,QAAAA,KACAJ,KAAAmE,cACAnE,KAAAoE,WACApE,KAAAqE,aA6EA,MA3EAjE,GAAAI,UAAA8D,kBAAA,SAAAC,GACA,GAAAC,GAAA,GAAAC,QAAArE,EAAAsE,aAAA,KACAC,EAAA,GAAAF,QAAArE,EAAAwE,aAAA,IACA,IAAAL,EAAAM,MAAAL,GACA,MAAAxE,MAAAoE,QAAAU,YAAAP,EAEA,IAAAA,EAAAM,MAAAF,GACA,MAAA3E,MAAAoE,QAAAW,YAAAR,EAGA,UAAAS,OAAA,mDAGA5E,EAAAI,UAAA8B,aAAA,SAAA7B,GACA,GAAAwE,GAAAjF,KAAAoE,QAAAc,kBAAAzE,EACA,OAAAwE,IAGA7E,EAAAI,UAAAH,QAAA,SAAAT,EAAAuF,GACA,GAAAC,GAAA,GAAAC,sBAAAzF,GACA0F,EAAAtF,KACAuF,EAAAH,EAAAI,iBAAA,WACA,IACAF,EAAAnB,WAAAoB,EAAAE,WAEA,MAAAnE,GACAV,QAAAW,MAAAD,GAEAgE,EAAAlB,QAAAkB,EAAAnB,WAAAuB,iBAAAC,QAAAC,kBACAN,EAAAnB,WAAA0B,MAAA,WACAV,SAKA/E,EAAAI,UAAAF,UAAA,SAAAwF,EAAAC,EAAAC,GAKA,GAAAC,GAAAjG,KAAAoE,QAAAU,YAAAgB,GACAI,EAAAlG,KAAAoE,QAAA+B,eAAAF,EACAjG,MAAAqE,UAAAyB,GAAAI,EACAA,EAAAE,mBAAA,SAAA3F,GACAsF,EAAAzG,KAAA0G,EAAAvF,EAAA4F,cAIAjG,EAAAI,UAAAsC,KAAA,SAAArC,EAAAwF,EAAAd,GACA,GAAAmB,GAAAtG,KAAAsE,kBAAA2B,GACAM,EAAAvG,KAAAoE,QAAAoC,eAAAF,GACArB,EAAAjF,KAAAsC,aAAA7B,EACA,KACA,GAAAgG,GAAAF,EAAAzD,KAAAmC,EAAA,WACAwB,EAAAC,WACA9F,QAAAW,MAAAkF,EAAAC,WAEAvB,MAGA,MAAAwB,GACA/F,QAAAW,MAAAoF,GAEAJ,EAAAK,SAEAxG,EAAAI,UAAAqG,YAAA,SAAAf,EAAAX,GACA,GAAAe,GAAAlG,KAAAqE,UAAAyB,EACAI,WACAlG,MAAAqE,UAAAyB,GACAI,EAAAU,MAAAzB,KAIA/E,EAAAsE,aAAA,QACAtE,EAAAwE,aAAA,QACAxE,IAEAlB,GAAAkB,YJ4NM,SAASjB,EAAQD,EAASH,GKlThC,YACA,IAAA+H,GAAA/H,EAAA,EACAG,GAAAkB,SAAA0G,EAAA1G","file":"WebRtcCDN.min.js","sourcesContent":["var WebRtcCDN =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ws_jms_lib_echyzen_1 = __webpack_require__(4);\n\t// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\t// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// } , function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// });\n\t// class ConfigWebRTC {\n\t//   constructor(public url: string, public channelID: string, public userID: string) { };\n\t//   static RESPONSE = \"response_web_rtc\";\n\t//   static REQUEST = \"request_web_rtc\"; \n\t//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n\t// }\n\t//\"ws-jms-lib-echyzen\": \"0.0.17\"\n\tvar WebRTCLib = (function () {\n\t    function WebRTCLib(url, channelID, userID) {\n\t        var _this = this;\n\t        this.url = url;\n\t        this.channelID = channelID;\n\t        this.userID = userID;\n\t        this.listTempRemoteIceCandidate = [];\n\t        this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n\t        this.wsJmsLib = new ws_jms_lib_echyzen_1.wsJmsLib();\n\t        this.wsJmsLib.connect(url, function () {\n\t            _this.wsJmsLib.subscribe(channelID, _this.dispatchMessage, _this);\n\t        });\n\t    }\n\t    WebRTCLib.prototype.dispatchMessage = function (message) {\n\t        var _this = this;\n\t        message = JSON.parse(message);\n\t        console.log('dispatchMessage', message);\n\t        switch (message.type) {\n\t            case 'request_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('request_web_rtc', message);\n\t                    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(this.tempRemoteDesc), function () {\n\t                        _this.myRTCPeerConnection.createAnswer(function (myDesc) {\n\t                            _this.getDescription(myDesc);\n\t                        }, function (err) { return console.error(err); });\n\t                    }, function (err) { return console.error(err); });\n\t                    this.tempRemoteDesc = message;\n\t                }\n\t                break;\n\t            case 'ice_candidate_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('ice_candidate_web_rtc', message);\n\t                    if (message.message) {\n\t                        this.listTempRemoteIceCandidate.push(message.message);\n\t                    }\n\t                    else {\n\t                        this.listTempRemoteIceCandidate.forEach(function (remoteIceCandidate) {\n\t                            _this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n\t                        });\n\t                    }\n\t                }\n\t                break;\n\t            case 'response_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('response_web_rtc', message);\n\t                    this.responseWebRTC(message.message);\n\t                }\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t    };\n\t    WebRTCLib.prototype.responseWebRTC = function (remoteDesc) {\n\t        this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n\t    };\n\t    WebRTCLib.prototype.getBrowserRTCConnectionObj = function () {\n\t        var servers = null;\n\t        var constraints = {\n\t            'optional': []\n\t        };\n\t        if (window.mozRTCPeerConnection) {\n\t            return new mozRTCPeerConnection(servers, constraints);\n\t        }\n\t        else if (window.webkitRTCPeerConnection) {\n\t            return new webkitRTCPeerConnection(servers, constraints);\n\t        }\n\t        else {\n\t            return new RTCPeerConnection(servers, constraints);\n\t        }\n\t    };\n\t    WebRTCLib.prototype.buildMessage = function (message, type) {\n\t        return {\n\t            chatroom_id: this.channelID,\n\t            user_id: this.userID,\n\t            type: type,\n\t            message: message\n\t        };\n\t    };\n\t    WebRTCLib.prototype.sendIceCandidates = function (myRTCIceCandidateEvent) {\n\t        var lightRTCIceCandidateEvent = null;\n\t        if (myRTCIceCandidateEvent.candidate) {\n\t            lightRTCIceCandidateEvent = {\n\t                sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n\t                sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n\t                candidate: myRTCIceCandidateEvent.candidate.candidate\n\t            };\n\t        }\n\t        var message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n\t        this.wsJmsLib.send(JSON.stringify(message), this.channelID, function () { });\n\t    };\n\t    WebRTCLib.prototype.getDescription = function (myDesc) {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.setLocalDescription(myDesc, function () {\n\t            var message = _this.buildMessage(myDesc, 'response_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        });\n\t    };\n\t    ////////////////////////////////////////////////////////////////\n\t    WebRTCLib.prototype.createStream = function (userMediaStream, getLocalStream, getRemoteStream) {\n\t        var _this = this;\n\t        navigator.getUserMedia(userMediaStream, function (myStream) {\n\t            _this.myRTCPeerConnection.addStream(myStream);\n\t            getLocalStream(myStream);\n\t            _this.myRTCPeerConnection.onicecandidate = function (myRTCIceCandidateEvent) {\n\t                _this.sendIceCandidates(myRTCIceCandidateEvent);\n\t            };\n\t            _this.myRTCPeerConnection.onaddstream = function (evt) {\n\t                getRemoteStream(evt.stream);\n\t            };\n\t        }, function (err) { return console.error(err); });\n\t    };\n\t    WebRTCLib.prototype.createOffer = function () {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.createOffer(function (myDesc) {\n\t            _this.myRTCPeerConnection.setLocalDescription(myDesc);\n\t            var message = _this.buildMessage(myDesc, 'request_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        }, function (err) { console.error(err); });\n\t    };\n\t    WebRTCLib.attachStream = function (mediaStream, HTMLElement) {\n\t        HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n\t    };\n\t    return WebRTCLib;\n\t}());\n\texports.WebRTCLib = WebRTCLib;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../typings/index.d.ts\" />\n\t/// <reference path=\"./Temasys.d.ts\" />\n\t\"use strict\";\n\tvar WebRTCLib_1 = __webpack_require__(1);\n\texports.WebRTCLib = WebRTCLib_1.WebRTCLib;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\t\"use strict\";\n\tvar wsJmsLib = (function () {\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    function wsJmsLib() {\n\t        this.connection = {};\n\t        this.session = {};\n\t        this.consumers = {};\n\t    }\n\t    wsJmsLib.prototype.createDestination = function (name) {\n\t        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n\t        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n\t        if (name.match(reTopic)) {\n\t            return this.session.createTopic(name);\n\t        }\n\t        else if (name.match(reQueue)) {\n\t            return this.session.createQueue(name);\n\t        }\n\t        else {\n\t            throw new Error(\"Destination must start with /topic/ or /queue/\");\n\t        }\n\t    };\n\t    wsJmsLib.prototype.buildMessage = function (message) {\n\t        var textMessage = this.session.createTextMessage(message);\n\t        return textMessage;\n\t    };\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    wsJmsLib.prototype.connect = function (url, callback) {\n\t        var connectionFactory = new JmsConnectionFactory(url);\n\t        var that = this;\n\t        var connectionFuture = connectionFactory.createConnection(function () {\n\t            try {\n\t                that.connection = connectionFuture.getValue();\n\t            }\n\t            catch (err) {\n\t                console.error(err);\n\t            }\n\t            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t            that.connection.start(function () {\n\t                callback();\n\t            });\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.subscribe = function (channelName, messageListener, context) {\n\t        // assuming connection has already been established and started\n\t        // ideally we need to maintain the state of the connection and throw error\n\t        // if the controller calls subscribe before connection is established\n\t        // or after the connection is closed\n\t        var topic = this.session.createTopic(channelName);\n\t        var consumer = this.session.createConsumer(topic);\n\t        this.consumers[channelName] = consumer;\n\t        consumer.setMessageListener(function (message) {\n\t            messageListener.call(context, message.getText());\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.send = function (message, topic, callback) {\n\t        var dest = this.createDestination(topic);\n\t        var producer = this.session.createProducer(dest);\n\t        var textMessage = this.buildMessage(message);\n\t        try {\n\t            var future_1 = producer.send(textMessage, function () {\n\t                if (future_1.exception) {\n\t                    console.error(future_1.exception);\n\t                }\n\t                callback();\n\t            });\n\t        }\n\t        catch (e) {\n\t            console.error(e);\n\t        }\n\t        producer.close();\n\t    };\n\t    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n\t        var consumer = this.consumers[channelName];\n\t        if (consumer) {\n\t            delete this.consumers[channelName];\n\t            consumer.close(callback);\n\t        }\n\t    };\n\t    ;\n\t    wsJmsLib.baseTopicUrl = 'topic';\n\t    wsJmsLib.baseQueueUrl = 'queue';\n\t    return wsJmsLib;\n\t}());\n\texports.wsJmsLib = wsJmsLib;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WsJMSLib_1 = __webpack_require__(3);\n\texports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// WebRtcCDN.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fcf2de7b15044910fc46","import {wsJmsLib} from 'ws-jms-lib-echyzen';\n\n// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\n// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// } , function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// });\n\n\n// class ConfigWebRTC {\n//   constructor(public url: string, public channelID: string, public userID: string) { };\n  \n//   static RESPONSE = \"response_web_rtc\";\n//   static REQUEST = \"request_web_rtc\"; \n//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n// }\n    //\"ws-jms-lib-echyzen\": \"0.0.17\"\n\nexport class WebRTCLib {\n\n  // private myCConfigWebRTC: ConfigWebRTC;\n\n  private myRTCPeerConnection: RTCPeerConnection;\n  private wsJmsLib: wsJmsLib\n\n  private tempRemoteDesc: RTCSessionDescriptionInit;\n  private listTempRemoteIceCandidate: RTCIceCandidate[] = [];\n\n\tconstructor(private url: string, private channelID: string, private userID: string) {\n    \n    this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n    this.wsJmsLib = new wsJmsLib();\n\n    this.wsJmsLib.connect(url, () => {\n      this.wsJmsLib.subscribe(channelID, this.dispatchMessage, this);\n    });  \n  }\n\n  private dispatchMessage(message: any): void {\n    message = JSON.parse(message);\n    console.log('dispatchMessage', message);\n    switch (message.type) {\n      case 'request_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('request_web_rtc', message);\n          this.myRTCPeerConnection.setRemoteDescription(\n            new RTCSessionDescription(this.tempRemoteDesc),\n            () => {\n              this.myRTCPeerConnection.createAnswer(\n                (myDesc: RTCSessionDescription) => {\n                  this.getDescription(myDesc);\n                }, \n                (err: Error) => console.error(err));\n          }, (err: Error) => console.error(err));\n        \n          this.tempRemoteDesc = message;\n        }\n        break;\n    \n      case 'ice_candidate_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('ice_candidate_web_rtc', message);\n          if(message.message) {\n            this.listTempRemoteIceCandidate.push(message.message);\n          } else {\n            this.listTempRemoteIceCandidate.forEach((remoteIceCandidate: RTCIceCandidate) => {\n              this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n            });\n          }\n          \n        }\n        break;\n\n      case 'response_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('response_web_rtc', message);\n          this.responseWebRTC(message.message);\n        }\n          \n        break;\n\n      default:\n        break;\n    }\n    \n  }\n\n  private responseWebRTC(remoteDesc: RTCSessionDescriptionInit) {\n    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n  }\n\n  private getBrowserRTCConnectionObj () {\n    let servers: RTCConfiguration = null;\n    let constraints: RTCMediaConstraints = {\n      'optional': []\n    };\n    if (window.mozRTCPeerConnection) {\n      return new mozRTCPeerConnection(servers, constraints);\n    } else if (window.webkitRTCPeerConnection) {\n        return new webkitRTCPeerConnection(servers, constraints);\n    } else {\n      return new RTCPeerConnection(servers, constraints);\n    }\n  }\n\n  private buildMessage(message: any, type: string) {\n    return {\n      chatroom_id: this.channelID,\n      user_id: this.userID,\n      type: type,\n      message: message\n    }\n  }\n\n  private sendIceCandidates(myRTCIceCandidateEvent: RTCIceCandidateEvent): void {\n    let lightRTCIceCandidateEvent: any = null;\n    if (myRTCIceCandidateEvent.candidate) {\n      lightRTCIceCandidateEvent = {\n        sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n        sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n        candidate: myRTCIceCandidateEvent.candidate.candidate\n      }\n    }\n    let message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n    this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n  }\n\n  private getDescription(myDesc: RTCSessionDescription) {\n    this.myRTCPeerConnection.setLocalDescription(myDesc,\n      () => {\n      let message = this.buildMessage(myDesc, 'response_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////\n\tpublic createStream(userMediaStream: MediaStreamConstraints,\n    getLocalStream: (stream: MediaStream) => any,\n    getRemoteStream: (stream: MediaStream) => any) {\n\n    navigator.getUserMedia(userMediaStream, (myStream) => {\n\n\t\t\t\tthis.myRTCPeerConnection.addStream(myStream);\n        getLocalStream(myStream);\n\n        this.myRTCPeerConnection.onicecandidate = (myRTCIceCandidateEvent: RTCIceCandidateEvent): void => {\n          this.sendIceCandidates(myRTCIceCandidateEvent);\n        };\n\n\t\t\t\tthis.myRTCPeerConnection.onaddstream = (evt: RTCMediaStreamEvent) => {\n          getRemoteStream(evt.stream);\n        }\n\t\t\n\t\t\t}, (err: Error) => console.error(err));\n\n\t}\n  \n  public createOffer() {\n    this.myRTCPeerConnection.createOffer( (myDesc: RTCSessionDescription) => {\n      this.myRTCPeerConnection.setLocalDescription(myDesc);\n      let message = this.buildMessage(myDesc, 'request_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    },(err: Error) => { console.error(err) });\n  }\n    \n\n  static attachStream(mediaStream: MediaStream, HTMLElement: HTMLElement) {\n    HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/WebRTCLib.ts","/// <reference path=\"../typings/index.d.ts\" />\n/// <reference path=\"./Temasys.d.ts\" />\n\nexport {WebRTCLib} from './WebRTCLib';\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.ts","/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\"use strict\";\nvar wsJmsLib = (function () {\n    //////////////////////////////////////////////////////////////////////////////////\n    function wsJmsLib() {\n        this.connection = {};\n        this.session = {};\n        this.consumers = {};\n    }\n    wsJmsLib.prototype.createDestination = function (name) {\n        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n        if (name.match(reTopic)) {\n            return this.session.createTopic(name);\n        }\n        else if (name.match(reQueue)) {\n            return this.session.createQueue(name);\n        }\n        else {\n            throw new Error(\"Destination must start with /topic/ or /queue/\");\n        }\n    };\n    wsJmsLib.prototype.buildMessage = function (message) {\n        var textMessage = this.session.createTextMessage(message);\n        return textMessage;\n    };\n    //////////////////////////////////////////////////////////////////////////////////\n    wsJmsLib.prototype.connect = function (url, callback) {\n        var connectionFactory = new JmsConnectionFactory(url);\n        var that = this;\n        var connectionFuture = connectionFactory.createConnection(function () {\n            try {\n                that.connection = connectionFuture.getValue();\n            }\n            catch (err) {\n                console.error(err);\n            }\n            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            that.connection.start(function () {\n                callback();\n            });\n        });\n    };\n    ;\n    wsJmsLib.prototype.subscribe = function (channelName, messageListener, context) {\n        // assuming connection has already been established and started\n        // ideally we need to maintain the state of the connection and throw error\n        // if the controller calls subscribe before connection is established\n        // or after the connection is closed\n        var topic = this.session.createTopic(channelName);\n        var consumer = this.session.createConsumer(topic);\n        this.consumers[channelName] = consumer;\n        consumer.setMessageListener(function (message) {\n            messageListener.call(context, message.getText());\n        });\n    };\n    ;\n    wsJmsLib.prototype.send = function (message, topic, callback) {\n        var dest = this.createDestination(topic);\n        var producer = this.session.createProducer(dest);\n        var textMessage = this.buildMessage(message);\n        try {\n            var future_1 = producer.send(textMessage, function () {\n                if (future_1.exception) {\n                    console.error(future_1.exception);\n                }\n                callback();\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n        producer.close();\n    };\n    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n        var consumer = this.consumers[channelName];\n        if (consumer) {\n            delete this.consumers[channelName];\n            consumer.close(callback);\n        }\n    };\n    ;\n    wsJmsLib.baseTopicUrl = 'topic';\n    wsJmsLib.baseQueueUrl = 'queue';\n    return wsJmsLib;\n}());\nexports.wsJmsLib = wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/WsJMSLib.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar WsJMSLib_1 = require('./WsJMSLib');\nexports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}